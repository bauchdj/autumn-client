import { createClient } from "@hey-api/openapi-ts";
import fs from "fs";
import nunjucks from "nunjucks";
import path from "path";

const templateStr = fs.readFileSync("src/index.njk", "utf-8");

function sanitizeString(str: string): string {
  return str.replace(/[^a-zA-Z0-9]+/g, "");
}

function toCamelCase(input: string): string {
  return input
    .replace(/[-_ ]+./g, (match) => match.charAt(match.length - 1).toUpperCase())
    .replace(/^[A-Z]/, (match) => match.toLowerCase());
}

// Helper to sanitize and PascalCase a string
function toPascalCase(str: string): string {
  return str
    .replace(/[^a-zA-Z0-9]+/g, " ") // non-alphanum to space
    .split(" ")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("")
    .replace(/\W/g, "");
}

// Get input path from CLI or env
function getInputPath(): string {
  const arg = process.argv.find((a) => a.startsWith("--input="));
  if (arg) return arg.split("=")[1];
  if (process.env.OPENAPI_INPUT) return process.env.OPENAPI_INPUT;
  return "openapi.json";
}

// 1. Generate src/client using hey-api/openapi-ts
async function generateClient(input: string) {
  await createClient({
    input,
    output: "src/client",
    plugins: ["@hey-api/client-fetch"],
  });
}

// 2. Render index.ts using nunjucks template
type ApiMethod = {
  operationId: string;
  name: string;
  path: string;
  method: string;
  description: string;
  paramType: string;
  respType: string;
  parameters: {
    name: string;
    type: string;
    required: boolean;
    description: string;
  }[];
  pathParams: string[];
  pathParamMap: Record<string, string>;
  sdkFunctionName: string;
};

type TemplateParams = {
  className: string;
  apiKey: string;
  apiMethods: ApiMethod[];
};

function renderIndex(params: TemplateParams) {
  // Create a Nunjucks environment with autoescape disabled to prevent HTML entity conversion
  const env = new nunjucks.Environment(undefined, { autoescape: false });
  return env.renderString(templateStr, params);
}

function getOpenAPISpec(input: string): any {
  const specRaw = fs.readFileSync(input, "utf-8");
  return JSON.parse(specRaw);
}

function getClassNameFromSpec(spec: any, input: string): string {
  if (spec.info && spec.info.title) {
    return toPascalCase(spec.info.title);
  }
  console.warn("Could not parse OpenAPI spec info.title, falling back to input filename.");
  return toPascalCase(path.basename(input, path.extname(input)));
}

function getApiKeyNameFromSpec(spec: any, input: string): string {
  if (spec.info && spec.info.title) {
    const firstWord = spec.info.title.split(" ")[0];
    return `${firstWord.toUpperCase()}_API_KEY`;
  }
  console.warn("Could not parse OpenAPI spec info.title, falling back to input filename.");
  return `${toPascalCase(path.basename(input, path.extname(input)))}_API_KEY`;
}

function replaceGeneratedComments(content: string): string {
  return content.replace(/^(\s*\/\/.*generat(e|ed)[^\n]*)/gim, "// generated by borea");
}

function getApiMethodsFromSpec(spec: any): ApiMethod[] {
  const methods: ApiMethod[] = [];

  // Iterate through all paths in the spec
  for (const [path, pathObj] of Object.entries(spec.paths || {})) {
    // Iterate through all HTTP methods for this path
    for (const [method, methodObj] of Object.entries(pathObj as object)) {
      if (method === "parameters") continue; // Skip path-level parameters
      const operationId = toCamelCase(methodObj.operationId) || `${method}${toPascalCase(path)}`;
      const methodName = operationId;
      const sdkFunctionName = operationId;
      const baseTypeName = toPascalCase(operationId);
      const paramType = `types.${baseTypeName}Data`;
      const respType = `types.${baseTypeName}Response`;

      const parameters: {
        name: string;
        type: string;
        required: boolean;
        description: string;
      }[] = [];

      // Add path parameters
      const pathParams: string[] = [];
      const pathParamRegex = /{([^}]+)}/g;
      let match;
      while ((match = pathParamRegex.exec(path)) !== null) {
        pathParams.push(match[1]);
      }

      // Add body parameter for POST methods
      if (method === "post") {
        parameters.push({
          name: "body",
          type: `${paramType}["body"]`,
          required: true,
          description: "Request body",
        });
      }

      // Add query parameters
      const queryParamRegex = /\?([^=]+=[^&]*)/g;
      let queryMatch;
      while ((queryMatch = queryParamRegex.exec(path)) !== null) {
        parameters.push({
          name: queryMatch[1].split("=")[0],
          type: "string",
          required: true,
          description: `Query parameter: ${queryMatch[1].split("=")[0]}`,
        });
      }

      // Add path parameters
      const pathParamMap: Record<string, string> = {};
      for (const param of pathParams) {
        parameters.push({
          name: param,
          type: "string",
          required: true,
          description: `Path parameter: ${param}`,
        });
        pathParamMap[param] = param;
      }

      methods.push({
        operationId,
        name: methodName,
        path,
        method,
        description: methodObj.description || `${method.toUpperCase()} ${path}`,
        paramType,
        respType,
        parameters,
        pathParams,
        pathParamMap,
        sdkFunctionName,
      });
    }
  }

  return methods;
}

async function main() {
  const input = getInputPath();
  await generateClient(input);

  const spec = getOpenAPISpec(input);
  const className = getClassNameFromSpec(spec, input);
  const apiKey = getApiKeyNameFromSpec(spec, input);
  const apiMethods = getApiMethodsFromSpec(spec);

  console.log(`Found ${apiMethods.length} API methods in the spec`);
  apiMethods.forEach((method) => {
    console.log(`- ${method.method.toUpperCase()} ${method.path} -> ${method.name}()`);
  });

  // Render and write index.ts
  const rendered = renderIndex({
    className,
    apiKey,
    apiMethods,
  });
  const indexPath = path.join("src", "client", "index.ts");
  fs.writeFileSync(indexPath, rendered, "utf-8");
  console.log(`src/client generated for class ${className}!`);

  // brand generated files
  const clientPath = path.join("src", "client");
  const files = fs.readdirSync(clientPath);
  for (const file of files) {
    if (file.endsWith(".gen.ts")) {
      const filePath = path.join(clientPath, file);
      const content = fs.readFileSync(filePath, "utf-8");
      const renderedContent = replaceGeneratedComments(content);
      fs.writeFileSync(filePath, renderedContent, "utf-8");
    }
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
